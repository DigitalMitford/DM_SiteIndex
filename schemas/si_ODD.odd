<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" version="2.9.1" xml:lang="en">
   
   
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Digital Mitford ODD for Site Index Files</title>
            <author>Elisa Beshero-Bondar</author>
         </titleStmt>
         <editionStmt xml:id="edition">
            <edition>First digital edition in TEI P5, prepared on <date when="2018-08-11">August 11, 2018</date> in Norwood, NY.</edition>
         </editionStmt>
         <publicationStmt>
            <authority>Prepared in TEI P5 by Elisa Beshero-Bondar in the Digital Mitford GitHub repository: <ref target="https://github.com/DigitalMitford/DM_SiteIndex"></ref>.
            </authority>
            <availability>
               <licence>Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) approved for Free Cultural Works <ref target="https://creativecommons.org/licenses/by-sa/4.0/"></ref>
               </licence>
            </availability>
         </publicationStmt>
         <seriesStmt>
            <p>This ODD customizes the TEI P5 for use in the prosopography index file known as our <q>Site Index</q>, which holds a narrower range of elements than in use in the wider project. It also customizes the TEI for all <q>SI-Add</q> files prepared as draft additional entries proposed for the published Site Index.</p>
         </seriesStmt>
         <sourceDesc>
            <p>Born digital, based on information presented in the Digital Mitford Codebook at <ref target="http://codebook.mitford.pitt.edu"></ref>
            </p>
         </sourceDesc>
      </fileDesc>
      <revisionDesc>
         <listChange>
            <change when="2018-08-11" who="#ebb">Prepared this ODD file while visiting Lisa Wilson in Norwood, NY.</change>
         </listChange>
      </revisionDesc>
   </teiHeader>
   <text>
      <body>
         <schemaSpec ident="siODD" prefix="tei" start="TEI teiCorpus">
            <moduleRef key="tei"></moduleRef>
            <moduleRef except="add addrLine address analytic biblStruct binaryObject cb choice corr del distinct divGen gap gb hi imprint index lb measure measureGrp media monogr pb speaker stage unclear" key="core"></moduleRef>
            <moduleRef key="header"></moduleRef>
            <moduleRef key="namesdates"></moduleRef>
            <moduleRef except="div1 div2 div3 div4 div5 div6 div7 argument byline closer dateline docAuthor docDate docEdition docImprint docTitle epigraph floatingText group imprimatur opener postscript salute signed titlePage titlePart trailer" key="textstructure"></moduleRef>
            <moduleRef key="linking"></moduleRef>
            <moduleRef except="formula notatedMusic" key="figures"></moduleRef>         
            <constraintSpec ident="xmlIDs" scheme="schematron">
               <constraint>
                  <sch:rule xmlns:sch="http://purl.oclc.org/dsdl/schematron" context="tei:TEI//@xml:id">
                     <sch:report role="fatal" test="matches(., '\s+')">
                        @xml:id values may NOT contain white spaces!
                     </sch:report>        
                  </sch:rule>
               </constraint>
            </constraintSpec>
            <constraintSpec ident="refsReq" scheme="schematron">
               <constraint>
                  <sch:rule xmlns:sch="http://purl.oclc.org/dsdl/schematron" context="tei:note//tei:persName[not(@ref)] | tei:note//tei:rs[not(@ref)] | tei:note//tei:placeName[not(@ref)] | tei:note//tei:orgName[not(@ref)] | tei:note//tei:name[not(@ref)] | tei:note//tei:title[not(@ref)]">
                     <sch:let name="currentNode" value="."></sch:let>
                     <sch:let name="matchingEntry" value="$currentNode[ancestor::tei:text//tei:*[@xml:id][not(self::* eq $currentNode/ancestor::*[1][@xml:id])]][*[not(self::tei:note) and not(self::tei:birth) and not (self::tei:death)][contains(string(), $currentNode)]]/@xml:id"></sch:let>
                     <sch:report role="info" test="$matchingEntry">
                        This element (coded in a note) is missing an @ref attribute but may have a matching entry in the Site Index: Could it be this (or one of these)? <sch:value-of select="string-join($matchingEntry, ', ')"></sch:value-of>.
                     </sch:report>  
                  </sch:rule>
               </constraint>
            </constraintSpec>
          
            <constraintSpec ident="hashtaggery" scheme="schematron">
               <constraint>
                  <sch:rule xmlns:sch="http://purl.oclc.org/dsdl/schematron" context="tei:TEI//@ref | tei:TEI//@who | tei:TEI//@corresp | tei:TEI//@wit">
                     <sch:assert role="fatal" test="starts-with(., '#')">
                        Attributes @ref, @who, @corresp, and @wit must begin with a hashtag.
                     </sch:assert>  
                  </sch:rule>
               </constraint>
            </constraintSpec>
            
<elementSpec ident="listPerson" mode="change" module="namesdates">
   <attList>
      <attDef ident="sortKey" mode="replace" usage="req">
         <valList type="closed">
            <valItem ident="Mitford_Team"></valItem>
            <valItem ident="Past_Assistants"></valItem>
            <valItem ident="Past_Editors"></valItem>
            <valItem ident="histPersons"></valItem>
            <valItem ident="archPersons"></valItem>
            <valItem ident="fictPersons"></valItem>
         </valList>
      </attDef>
   </attList>
</elementSpec>
<elementSpec ident="listPlace" mode="change" module="namesdates">
     <attList>
         <attDef ident="sortKey" mode="replace" usage="req">
             <valList type="closed">
                 <valItem ident="histPlaces"></valItem>
                 <valItem ident="fictPlaces"></valItem>
              </valList>
           </attDef>
       </attList>
</elementSpec>
            <elementSpec ident="listOrg" mode="change" module="namesdates">
               <attList>
                  <attDef ident="sortKey" mode="replace" usage="req">
                     <valList type="closed">
                        <valItem ident="archives"></valItem>
                        <valItem ident="histOrgs"></valItem>
                        <valItem ident="fictOrgs"></valItem>
                        <valItem ident="archOrgs"></valItem>
                     </valList>
                  </attDef>
               </attList>
            </elementSpec>
            <elementSpec ident="listEvent" mode="change" module="namesdates">
               <attList>
                  <attDef ident="sortKey" mode="replace" usage="req">
                     <valList type="closed">
                        <valItem ident="histEvents"></valItem>
                     </valList>
                  </attDef>
               </attList>
            </elementSpec>
            <elementSpec ident="listBibl" mode="change" module="core">
               <attList>
                  <attDef ident="sortKey" mode="replace" usage="req">
                     <valList type="closed">
                        <valItem ident="work_MRM"></valItem>
                        <valItem ident="serial_MRM"></valItem>
                        <valItem ident="schol"></valItem>
                     </valList>
                  </attDef>
               </attList>
            </elementSpec> 
            <elementSpec ident="list" mode="change" module="core">
               <attList>
                  <attDef ident="sortKey" mode="replace" usage="req">
                     <valList type="closed">
                        <valItem ident="plants"></valItem>
                        <valItem ident="animals"></valItem>
                        <valItem ident="art"></valItem>
                     </valList>
                  </attDef>
               </attList>
            </elementSpec> 
            
                       
            <elementSpec ident="person" mode="change" module="namesdates">
               <attList>
                  <attDef ident="sex" mode="replace" usage="rec">
                     <valList type="closed">
                        <valItem ident="m"><gloss>for persons identified as male.</gloss></valItem>
                        <valItem ident="f"><gloss>for persons identified as female.</gloss></valItem>
                        <valItem ident="m f"><gloss>for persons identified as of transitional or multiple sexual identities.</gloss></valItem>
                        <valItem ident="u"><gloss>for persons with unidentified or unknown sexual identity.</gloss></valItem>  
                     </valList>
                  </attDef>
               </attList>
            </elementSpec>
            <elementSpec ident="rs" mode="change" module="core">
               <attList>
                  <attDef ident="type" mode="replace" usage="req">
                     <valList type="closed">
                        <valItem ident="person">
                           <gloss>Use only when you need to disambiguate unnamed references to people. When there is a name, use the persName element.</gloss>
                        </valItem>
                        <valItem ident="org">
                           <gloss>Use only when you need to disambiguate unnamed references to organizations, families, collectives of people. When there is a name, use the orgName element.</gloss>
                        </valItem>
                        <valItem ident="place">
                           <gloss>Use only when you need to disambiguate unnamed references to places. When there is a name, use the placeName element.</gloss>
                        </valItem>
                        <valItem ident="event">
                           <gloss>Use only when you need to disambiguate unnamed references to events. When there is a name, use the name element with type="event".</gloss>
                        </valItem>
                        <valItem ident="letter">
                           <gloss>Use to mark references to correspondence.</gloss>
                        </valItem>
                        <valItem ident="plant">
                           <gloss>Use to mark references to plants by kind, variety, genus, and/or species. If you see a kind, variety, genus, and/or species name, use the &lt;name&gt; element (instead of &lt;rs&gt;) with type="plant".</gloss>
                        </valItem>
                        <valItem ident="animal">
                           <gloss>Use to mark references to animal types when they are unnamed by kind, variety, genus, and/or species. If you see a kind, variety, genus, and/or species name, use the name element with type="animal". </gloss>
                        </valItem>
                        <valItem ident="title">
                           <gloss>Use only where necessary to mark unnamed references to documents, readings, texts in the absence of a title. If this is a title, use the title element with an @ref. If there is mention of an author, date, or other bibliographic information all together, like Scott's Midlothian, use a bibl element with @corresp around the full span of referencing text, wrapping the parts as you can with author and title elements (no @ref attributes needed inside, just @corresp on the outer bibl) .</gloss>
                        </valItem>
                        <valItem ident="art">
                           <gloss>Use only where necessary to mark unnamed references to works of art in the absence of a title. If you have a title, use the title element with type="art".</gloss>
                        </valItem>
                     </valList>
                  </attDef>
               </attList>
            </elementSpec>
            
            
            
            <elementSpec ident="occupation" mode="change" module="namesdates" xml:base="ODD_includes/occupationsElem.xml" xml:lang="en">
    <content>
        <elementRef key="roleName" maxOccurs="unbounded" minOccurs="0"></elementRef>
    </content>
    <attList>
        <attDef ident="type" mode="replace" usage="req">
            <valList type="closed">
                <valItem ident="artist"></valItem>
                <valItem ident="bookProducer"></valItem>
                <valItem ident="religious"></valItem>
                <valItem ident="educator"></valItem>
                <valItem ident="scholar"></valItem>
                <valItem ident="explorer"></valItem>
                <valItem ident="legal"></valItem>
                <valItem ident="literary"></valItem>
                <valItem ident="theater"></valItem>
                <valItem ident="medical"></valItem>
                <valItem ident="military"></valItem>
                <valItem ident="benefactor"></valItem>
                <valItem ident="government"></valItem>
                <valItem ident="service"></valItem>
                <valItem ident="trade"></valItem>                
            </valList>
        </attDef>
        <attDef ident="subtype" mode="replace" usage="opt">
            <datatype><dataRef name="string"></dataRef></datatype>
            <valList type="semi">
                
                <valItem ident="painter"><gloss>with type="artist": Designate type of painter as appropriate in the note element.</gloss></valItem>
                <valItem ident="printmaker"><gloss>with type="artist": this includes printmaking for books.</gloss></valItem>
                <valItem ident="engraver"><gloss>with type="artist": this includes engravings for books.</gloss></valItem> 
                <valItem ident="sculptor"><gloss>with type="artist".</gloss></valItem>
                <valItem ident="architect"><gloss>with type="artist". for designers of buildings.</gloss></valItem>
                <valItem ident="landscape"><gloss>with type="artist". for designers and planners of gardens. The occupation of gardener, for one who helps maintain a garden, goes with @type="service" </gloss></valItem>
                <valItem ident="illustrator"><gloss>with type="artist". This includes book illustrators.</gloss></valItem>
                
                <valItem ident="publisher"><gloss>with type="bookProducer".</gloss></valItem>
                <valItem ident="printer"><gloss>with type="bookProducer". Do not use for art printing. For that, use one of the subtypes associated with type="artist".</gloss></valItem>
                <valItem ident="binder"><gloss>with type="bookProducer".</gloss></valItem>
                <valItem ident="bookseller"><gloss>with type="bookProducer".</gloss></valItem>
                
                <valItem ident="clergy"><gloss>with type="religious".</gloss></valItem>
                <valItem ident="prophet"><gloss>with type="religious".</gloss></valItem>
                <valItem ident="vicar"><gloss>with type="religious".</gloss></valItem>
                <valItem ident="curate"><gloss>with type="religious".</gloss></valItem>
                <valItem ident="minister"><gloss>with type="religious".</gloss></valItem>
                <valItem ident="rector"><gloss>with type="religious".</gloss></valItem>
                <valItem ident="priest"><gloss>with type="religious". Use for Catholic clergy as well as Greek/Roman clergy. Synonymous with priestess for the purposes of our encoding.</gloss></valItem>
                <valItem ident="composer"><gloss>with type="religious". For composers of religious music.</gloss></valItem>
                <valItem ident="musician"><gloss>with type="religious". For musical performers in church settings and religious contexts.</gloss></valItem>
                <valItem ident="churchAssist"><gloss>with type="religious". For non-leadership roles serving the church (such as pew-opener).</gloss></valItem>
                
                <valItem ident="teacher"><gloss>with type="educator".</gloss></valItem>
                <valItem ident="schoolHead"><gloss>with type="educator". (for headmistress, schoolmaster, etc.)</gloss></valItem>
                <valItem ident="governess"><gloss>with type="educator".</gloss></valItem>
                <valItem ident="tutor"><gloss>with type="educator".</gloss></valItem>
                <valItem ident="lecturer"><gloss>with type="educator". For public lecturers on educational topics.</gloss></valItem>
                
                <valItem ident="philosopher"><gloss>with type="scholar". Distinct from natural philosopher.</gloss></valItem> 
                <valItem ident="naturalist"><gloss>with type="scholar". Covers the natural sciences and earth sciences, and includes biologist, botanist, ornithologist, geologist, etc.</gloss></valItem>
                <valItem ident="astronomer"><gloss>with type="scholar".</gloss></valItem> 
                <valItem ident="curator"><gloss>with type="scholar". for antiquarian collectors and those working in libraries and museums.</gloss></valItem>
                <valItem ident="antiquarian"><gloss>with type="scholar". For those who research artifacts rather than collect them.</gloss></valItem>
                <valItem ident="historian"><gloss>with type="scholar". </gloss></valItem>
                <valItem ident="inventor"><gloss>with type="scholar". </gloss></valItem>
                <valItem ident="economist"><gloss>with type="scholar". </gloss></valItem>
                <valItem ident="agronomist"><gloss>with type="scholar". For those who study agriculture.</gloss></valItem>
                 
                <valItem ident="traveller"><gloss>with type="explorer".</gloss></valItem>
                <valItem ident="navigator"><gloss>with type="explorer".</gloss></valItem>
                <valItem ident="cartographer"><gloss>with type="explorer".</gloss></valItem>
                <valItem ident="seaCaptain"><gloss>with type="explorer". Commands a ship, distinct from military post.</gloss></valItem>
                 
                <valItem ident="barrister"><gloss>with type="legal". British lawyers who can plead in court.</gloss></valItem>
                <valItem ident="solicitor"><gloss>with type="legal". British lawyers who do not plead in court.</gloss></valItem>
                <valItem ident="lawyer"><gloss>with type="legal". ONLY appropriate if law practitioner from the United States.</gloss></valItem> 
                <valItem ident="recorder"><gloss>with type="legal". </gloss></valItem> 
                <valItem ident="judge"><gloss>with type="legal". ex: Mr. Justice Talfourd</gloss></valItem>  
                <valItem ident="magistrate"><gloss>with type="legal". ex: George Mitford</gloss></valItem>  
                <valItem ident="enforcement"><gloss>with type="legal". For constable, police, or sheriff, those involved in law enforcement.</gloss></valItem>
                
                <valItem ident="novelist"><gloss>with type="literary". </gloss></valItem> 
                <valItem ident="poet"><gloss>with type="literary". </gloss></valItem> 
                <valItem ident="playwright"><gloss>with type="literary". </gloss></valItem> 
                <valItem ident="essayist"><gloss>with type="literary". For essayists who are not primarily writing specific literary/art reviews, but more broad-ranging philosophical or aesthetic writings.</gloss></valItem> 
                <valItem ident="critic"><gloss>with type="literary". For literary, theatre / art critics and reviewers.</gloss></valItem> 
                <valItem ident="journalist"><gloss>with type="literary". </gloss></valItem> 
                <valItem ident="editor"><gloss>with type="literary". </gloss></valItem> 
                <valItem ident="biographer"><gloss>with type="literary". </gloss></valItem> 
                <valItem ident="autobiographer"><gloss>with type="literary". </gloss></valItem> 
                <valItem ident="lexicographer"><gloss>with type="literary". </gloss></valItem> 
                <valItem ident="linguist"><gloss>with type="literary". For those who systemically study languages, not simply translators.</gloss></valItem> 
                <valItem ident="translator"><gloss>with type="literary". </gloss></valItem> 
                  
                <valItem ident="actor"><gloss>with type="theater". General term for all sexes; do not use "actress".</gloss></valItem> 
                <valItem ident="singer"><gloss>with type="theater". Includes opera singers in performing roles. </gloss></valItem> 
                <valItem ident="manager"><gloss>with type="theater". For actor-managers and theater managers like William Macready.</gloss></valItem> 
                <valItem ident="owner"><gloss>with type="theater". </gloss></valItem> 
                <valItem ident="designer"><gloss>with type="theater". For production designers, costume-makers, makers of stage sets and props.</gloss></valItem> 
                <valItem ident="musician"><gloss>with type="theater". For pit players of music supporting the stage.</gloss></valItem>   
                <valItem ident="composer"><gloss>with type="theater". For writers of instrumental and vocal music for the stage, including lyricists and librettists.</gloss></valItem>
                
                <valItem ident="physician"><gloss>with type="medical".</gloss></valItem>
                <valItem ident="surgeon"><gloss>with type="medical". Includes barbers and others who do surgery and bloodletting.</gloss></valItem>
                <valItem ident="apothecary"><gloss>with type="medical". For pharmacy specialists.</gloss></valItem>
                <valItem ident="midwife"><gloss>with type="medical". Includes, should we ever see one, a "man-midwife" or a male who assists with births and is not a physician or surgeon.</gloss></valItem>
                <valItem ident="oculist"><gloss>with type="medical".</gloss></valItem>
                
                <valItem ident="army"><gloss>with type="military".</gloss></valItem>    
                <valItem ident="navy"><gloss>with type="military".</gloss></valItem>
                
                <valItem ident="philanthropist"><gloss>with type="benefactor". For doers of benevolent activities outside of the arts</gloss></valItem>
                <valItem ident="patron"><gloss>with type="benefactor". For supporters of the arts, theatre, and writers</gloss></valItem>
                <valItem ident="volunteer"><gloss>with type="benefactor". For individual benevolent activities involving labor rather than money</gloss></valItem>
                
                <valItem ident="monarch"><gloss>with type="government". Titles like King, Queen, Princess are coded in &lt;roleName&gt;, not &lt;occupation&gt;.</gloss></valItem> 
                <valItem ident="politician"><gloss>with type="government". Use for elected officials and those running for election or who are in office by reason of political party or affiliation. Code their official title (such as "Member of Parliament for Westminster) with &lt;roleName&gt;.</gloss></valItem>  
                <valItem ident="orator"><gloss>with type="government". For political or reformist orators who are not clergy, actors, or prophets.</gloss></valItem>  
                <valItem ident="reformer"><gloss>with type="government". Any public advocate for political or social reform.</gloss></valItem>  
                <valItem ident="courtier"><gloss>with type="government". For aristocracy and others whose job is to serve at court in some capacity.</gloss></valItem>  
                <valItem ident="diplomat"><gloss>with type="government". Ambassadors and other diplomatists. Roles like “Ambassador to the Court of St. James” are coded in &lt;roleName&gt;.</gloss></valItem>  
                <valItem ident="administrator"><gloss>with type="government". For management positions, high-ranking civil service positions within the British empire, etc. Lower-ranking positions should be coded as subtype="clerk".</gloss></valItem>  
                <valItem ident="clerk"><gloss>with type="government".</gloss></valItem>  
                <valItem ident="taxCollector"><gloss>with type="government".</gloss></valItem>  
                <valItem ident="post"><gloss>with type="government". For postal service occupations.</gloss></valItem>
                
                <valItem ident="butler"><gloss>with type="service".</gloss></valItem>
                <valItem ident="coachman"><gloss>with type="service".</gloss></valItem>
                <valItem ident="maid"><gloss>with type="service".</gloss></valItem>
                <valItem ident="manservant"><gloss>with type="service".</gloss></valItem>
                <valItem ident="valet"><gloss>with type="service".</gloss></valItem>
                <valItem ident="footman"><gloss>with type="service".</gloss></valItem> 
                <valItem ident="cook"><gloss>with type="service".</gloss></valItem>
                <valItem ident="housekeeper"><gloss>with type="service".</gloss></valItem>   
                <valItem ident="gardener"><gloss>with type="service".</gloss></valItem>
                
                <valItem ident="baker"><gloss>with type="trade".</gloss></valItem>
                <valItem ident="butcher"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="farmer"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="bricklayer"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="mason"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="chandler"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="wheelwright"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="carpenter"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="watchmaker"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="miller"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="blacksmith"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="goldsmith"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="jeweller"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="tanner"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="saddler"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="bootmaker"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="shoemaker"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="innkeeper"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="liquor"><gloss>with type="trade". For a retailer of beer/wine.</gloss></valItem>  
                <valItem ident="merchant"><gloss>with type="trade".</gloss></valItem>
                <valItem ident="clerk"><gloss>with type="trade". For an employee in a shop.</gloss></valItem> 
                <valItem ident="banker"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="stockbroker"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="auctioneer"><gloss>with type="trade".</gloss></valItem> 
                <valItem ident="gambler"><gloss>with type="trade".</gloss></valItem> 
            </valList>      
        </attDef>
    </attList>
    <exemplum>
        <p>The <gi>occupation</gi> element in lists of editors and assistants on the Digital Mitford project should contain a roleName to contain institutional roles and affiliation:</p>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
            <occupation type="scholar"><roleName>Assistant Professor of English <affiliation>Missouri Southern State
                University</affiliation></roleName>
            </occupation>
        </egXML>
    </exemplum>
    <exemplum>
        <p>When the <gi>occupation</gi> element appears in other lists (for historical or fictional persons) in the site index, it is an empty element, and must hold attributes for typing and subtyping:</p>
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
            <occupation subtype="playwright" type="literary"></occupation>
        </egXML>
    </exemplum>
</elementSpec>
            
         
            <constraintSpec ident="occupation" scheme="schematron" xml:base="ODD_includes/occupationsSchem.xml" xml:lang="en">
    <constraint>
        <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
            <sch:let name="artistSubtypes" value="('painter', 'printmaker', 'engraver', 'sculptor', 'architect', 'landscape', 'illustrator')"></sch:let>
            <sch:let name="bookProducerSubtypes" value="('publisher', 'printer', 'binder', 'bookseller')"></sch:let>
            <sch:let name="religiousSubtypes" value="('clergy', 'prophet', 'vicar', 'curate', 'minister', 'rector', 'priest', 'musician', 'composer', 'churchAssist')"></sch:let>
            <sch:let name="educatorSubtypes" value="('teacher', 'schoolHead', 'governess', 'tutor', 'lecturer')"></sch:let>
            <sch:let name="scholarSubtypes" value="('philosopher', 'naturalist', 'astronomer', 'curator', 'antiquarian', 'inventor', 'historian', 'economist', 'agronomist')"></sch:let>
            <sch:let name="explorerSubtypes" value="('traveller', 'navigator', 'cartographer', 'seaCaptain')"></sch:let>
            <sch:let name="legalSubtypes" value="('barrister', 'solicitor', 'lawyer', 'recorder', 'magistrate', 'judge', 'enforcement')"></sch:let>
            <sch:let name="literarySubtypes" value="('novelist', 'poet', 'playwright', 'essayist', 'critic', 'journalist', 'editor', 'biographer', 'autobiographer', 'lexicographer', 'linguist', 'translator')"></sch:let>
            <sch:let name="theaterSubtypes" value="('actor', 'singer', 'manager', 'owner', 'designer', 'musician', 'composer')"></sch:let>
            <sch:let name="medicalSubtypes" value="('physician', 'surgeon', 'apothecary', 'midwife', 'oculist')"></sch:let>
            <sch:let name="militarySubtypes" value="('army', 'navy')"></sch:let>
            <sch:let name="benefactorSubtypes" value="('philanthropist', 'patron', 'volunteer')"></sch:let>
            <sch:let name="governmentSubtypes" value="('monarch', 'politician', 'orator', 'reformer', 'courtier', 'diplomat', 'administrator', 'clerk', 'taxCollector', 'post')"></sch:let>
            <sch:let name="serviceSubtypes" value="('butler', 'coachman', 'valet', 'maid', 'manservant', 'footman', 'cook', 'housekeeper', 'gardener')"></sch:let>
            <sch:let name="tradeSubtypes" value="('baker', 'butcher', 'farmer', 'bricklayer', 'mason', 'chandler', 'wheelwright', 'carpenter', 'watchmaker', 'miller', 'blacksmith', 'goldsmith', 'jeweller', 'tanner', 'saddler', 'bootmaker', 'shoemaker', 'innkeeper', 'liquor', 'merchant', 'clerk', 'banker', 'stockbroker', 'auctioneer', 'gambler')"></sch:let>
            <sch:rule context="tei:occupation[@type='artist'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $artistSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$artistSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='bookProducer'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $bookProducerSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$bookProducerSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='religious'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $religiousSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$religiousSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='educator'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $educatorSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$educatorSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='scholar'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $scholarSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$scholarSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='explorer'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $explorerSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$explorerSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='legal'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $legalSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$legalSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='literary'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $literarySubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$literarySubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='theater'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $theaterSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$theaterSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='medical'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $medicalSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$medicalSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='military'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $militarySubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$militarySubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='benefactor'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $benefactorSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$benefactorSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='government'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $governmentSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$governmentSubtypes"></sch:value-of>.</sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='service'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $serviceSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$serviceSubtypes"></sch:value-of></sch:assert>
            </sch:rule>
            <sch:rule context="tei:occupation[@type='trade'][@subtype]">
                <sch:let name="subtypes" value=" for $i in tokenize(@subtype, '\s+') return $i"></sch:let>
                <sch:assert test="every $subtype in $subtypes satisfies $subtype = $tradeSubtypes">Multiple subtypes are permitted, but these must be from the following list: <sch:value-of select="$tradeSubtypes"></sch:value-of></sch:assert>
            </sch:rule>  
        </sch:pattern>
    </constraint>
</constraintSpec>

            <constraintSpec ident="quotes" scheme="schematron">
               <constraint>
                  <sch:rule xmlns:sch="http://purl.oclc.org/dsdl/schematron" context="tei:note//text()[matches(., '[A-z]+')]">
                     <sch:let name="regexQuote" value="'&quot;'"></sch:let>
                     <sch:report role="warning" test="matches(., $regexQuote)">
                        We see you’re typing in quotation marks. Please use a meaningful TEI element for these, instead, and do not duplicate quotation marks with a TEI element, because this may result in multiple sets of quotation marks on the website. If this is a cited quotation, use the cit and quote elements together (or just the quote element for an uncited quotation). If it is a spoken aloud passage, use the said element. If it is a title of a poem or other short work, use &lt;title level="a"&gt;. If it is a string of words in quotation marks and you are not sure what it is, use the q element.</sch:report>        
                  </sch:rule>
               </constraint>
            </constraintSpec>
            <constraintSpec ident="SI_Guidance" scheme="schematron"><constraint>     
               <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:p>Look for strings in note elements and label elements that might want/need to be tagged for cross-referencing. </sch:p>
               </sch:pattern>
               <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:p>Identify stub entries.</sch:p>
                  <sch:rule context="*[@xml:id]">
                     <sch:report role="warning" test="count(child::*) eq 1">Warning: stub element. We should flesh this out and add more information.</sch:report>
                  </sch:rule>
               </sch:pattern>
               <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:rule context="tei:person[descendant::tei:surname = //tei:surname[not(ancestor::tei:person = self::tei:person)]]">
                     <sch:let name="currentContext" value="."></sch:let>
                     <sch:let name="sharedSurname" value="//tei:person[not(. = $currentContext)][descendant::tei:surname = $currentContext/descendant::tei:surname]"></sch:let>
                     <sch:report role="warning" test="descendant::tei:forename = $sharedSurname//tei:forename">
                        Warning! Is this a duplicate entry? The person represented in this entry shares a surname and a forename with one or more other entries: <sch:value-of select="string-join($sharedSurname[descendant::tei:forename = $currentContext//tei:forename]/@xml:id, ', ')"></sch:value-of>
                     </sch:report>
                  </sch:rule>
               </sch:pattern>
               <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:p>This rule will test the plausibilty of birth dates in relation to death dates.</sch:p>
                  <sch:rule context="tei:person[tei:birth/@*[matches(., '^\d')] and tei:death/@*[matches(., '^\d')]]">
                     <sch:assert test="tei:birth/@* &lt; tei:death/@*">Birth dates must be earlier than death dates.</sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:person[tei:birth/@*[matches(., '^-')] and tei:death/@*[matches(., '^-')]]">
                     <sch:assert test="tei:birth/@* > tei:death/@*">When dates begin with a minus sign (BCE), the value for the birth year must be a larger negative number than the death year. Birth dates must be earlier than death dates.</sch:assert>
                  </sch:rule>
                  <sch:rule context="tei:person[tei:death/@*[matches(., '^-')]]"><sch:report test="tei:birth/@*[matches(., '^\d')]">This birth date seems to be positive (ADE) while the death date is negative (BCE). Birth dates must be earlier than death dates.</sch:report>
                  </sch:rule>
                  <sch:rule context="tei:person[tei:birth/@*[matches(., '^-')]]">
                     <sch:report test="tei:death/@*[matches(., '^\d')] and tei:death/@*/number() > 99">This birth date seems to be negative (BCE) while the death date is positive (ADE) and greater than 99, which seems an excessively long life span. Check if the dates are correct?</sch:report>
                  </sch:rule>
               </sch:pattern>
               <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:rule context="@sex">
                     <sch:report test="matches(., '[0-9,]')">
                        We are no longer using the ISO numerical codes for sex, and this attribute may not contain commas. Change this code to a letter, one (or more) of the following approved values: m, f, m f, and u. If indicating multiple values, separate each with just a white space.
                     </sch:report>
                     
                  </sch:rule>
                  
               </sch:pattern>
               
               
               <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:rule context="tei:text//@xml:id">
                     <sch:report test="matches(., '\s+')">
                        @xml:id values must not contain white spaces.
                     </sch:report>   
                     <sch:report test="starts-with(., '#')">
                        @xml:id values must not begin with a hashtag.
                     </sch:report>
                  </sch:rule>
               </sch:pattern>
               <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:rule context="tei:TEI"> 
                     <sch:assert test="count(distinct-values(//@sortKey)) eq count(//*[@sortKey])">
                        There must not be any duplicate @sortkey values in the site index! 
                     </sch:assert>
                  </sch:rule>  
               </sch:pattern>
               <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                  <sch:let name="si" value="doc('http://digitalmitford.org/si.xml')//@xml:id"></sch:let> 
                  
                  <sch:let name="siAddcoll" value="collection('../si_Add_Staged/catalogue.xml')//@xml:id"></sch:let>
                  <sch:let name="siAll" value="($si, $siAddcoll)"></sch:let>
                  <sch:rule context="@ref | @corresp | @resp">
                     
                     <sch:let name="tokens" value="for $w in tokenize(., '\s+') return substring-after($w, '#')"></sch:let>
                     <sch:assert test="every $token in $tokens satisfies $token = //tei:text//@xml:id | $si">
                        Did you begin your @ref or @corresp value with a hashtag? If that's not the problem, check that the attribute of @ref or @corresp (after the hashtag, #) matches a defined @xml:id in the site index or siAdd files. 
                     </sch:assert>                
                  </sch:rule>
               </sch:pattern>      
            </constraint>
            </constraintSpec>
            <constraintSpec ident="noteGuidance" scheme="schematron">
               <constraint>
                  <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                     <sch:title>Multi-paragraph notes</sch:title>
                     <sch:rule context="tei:note">
                        <sch:report role="info" test="count(descendant::tei:p) gt 1">This note is multiple paragraphs long, and may need to be trimmed. Should we consider condensing it?</sch:report>
                     </sch:rule>
                  </sch:pattern>
                  <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                     <sch:title>Does the first paragraph contain a Mitford reference?</sch:title>
                     <sch:rule context="tei:note[count(descendant::tei:p) gt 1]//tei:p[1]">
                        <sch:assert role="warning" test="contains(., 'Mitford')">In this multi-paragraph note, the first paragraph needs to mention Mitford in some way to prioritize MRM’s relationship with this named entity.</sch:assert>
                     </sch:rule>
                  </sch:pattern>
                  <sch:pattern xmlns:sch="http://purl.oclc.org/dsdl/schematron">
                     <sch:title>Mentions of birth and death</sch:title>
                     <sch:rule context="tei:note">
                        <sch:report role="info" test="contains(., 'was born') or contains(., ' [Bb]orn') or contains(., ' [Dd]ied')">We notice the phrase(s) “was born”, “born,” or “died” appear somewhere in this note. If these passages duplicate info in the birth or death elements elsewehere in this entry, they should be removed, since it will represent duplicate output on the site.</sch:report>
                     </sch:rule>
                  </sch:pattern>
               </constraint>
            </constraintSpec>
         </schemaSpec> 
      </body>
  </text>
</TEI>